<!DOCTYPE html>
<html>
<head>
<title>Algorithms</title>
</head>
<body>
<h1>Algorithms</h1>
<hr />
<h2>Regex (findall, sub) Counter</h2>
<hr />
<h3>Python</h3>
<pre>
    import re
    from collections import Counter

    def count_words(sentence):
        sentence = re.sub(r'[!&@$%^&_]', ' ', sentence)
        return Counter(re.findall(r'\b[a-zA-Z0-9\']+\b', sentence.lower()))
</pre>
<h3>JavaScript</h3>
<pre>
    export const countWords = s => {
        const wordCnt = {};
        s.toLowerCase()
          .replace(/[!@$%^&_]/g, ' ')
          .match(/\w+('[\w+])?/g)
          .map(word => {
            wordCnt[word] ? wordCnt[word]++ : wordCnt[word] = 1
          });
        return wordCnt;
    };
</pre>
<h3>C#</h3>
<pre>
    using System.Linq;
    using System.Collections.Generic;
    using System.Text.RegularExpressions;

    public static class WordCount
    {
        public static IDictionary<string, int> CountWords(string phrase) 
        {
            return new Regex(@"\w+('\w)*")
            .Matches(phrase.ToLower())
            .ToLookup(word => word.Value)
            .ToDictionary(wordMap => wordMap.Key, wordMap => wordMap.Count());
        } 
    }
</pre>
<h3>Go</h3>
<pre>
    package wordcount

    import (
        "regexp"
        "strings"
    )

    // Frequency maps word counts
    type Frequency map[string]int

    // WordCount populates WordMap
    func WordCount(s string) Frequency {
        freq := make(Frequency)
        re := regexp.MustCompile(`([a-z]+'?[a-z]+|[0-9])+`)
        words := re.FindAllString(strings.ToLower(s), -1)
        for _, word := range words {
            freq[word]++
        }
        return freq
    }
</pre>

<hr />
<h2>Regex (search, sub)</h2>
<hr />
<h3>Python</h3>
<pre>
    import re

    def is_paired(input_string): 
        input_string = re.sub(r'[^()[\]{}]', '', input_string)
        while re.search(r'\(\)|\[\]|\{\}', input_string):
            input_string = re.sub(r'\(\)|\[\]|\{\}', '', input_string)

        return len(input_string) == 0
</pre>

<hr />
<h2>Reverse</h2>
<hr />
<h3>Python</h3>
<pre>
    def reverse(text):
        return ''.join(reversed(text))
</pre>
<h3>JavaScript</h3>
<pre>
    export const reverseString = str => {
        return str.split('').reduce((rev, char) => char + rev, '');
    };
</pre>
<h3>C#</h3>
<pre>
    using System;
    using System.Linq;
        
    public static class ReverseString
    {
        public static string Reverse(string input) => new string(input.Reverse().ToArray());
    }
</pre>
<h3>Go</h3>
<pre>
    package reverse

    // Reverse reverses string
    func Reverse(str string) string {
        rs := []rune(str)
        n := len(rs)
        for i := 0; i < n/2; i++ {
            rs[i], rs[n-1-i] = rs[n-1-i], rs[i]
        }

        return string(rs)
    }
</pre>

<hr />
<h2>Set</h2>
<hr />
<h3>Python</h3>
<pre>
    def is_isogram(string):
    charset = set()
    for c in string.lower():
        if c in charset and c.isalpha():
            return False
        else:
            charset.add(c)

    return True 

    def is_isogram(string):
        iso_check = set(re.findall(r'\w', string))
        return len(iso_check) == len(re.findall(r'\w', string))

    def is_isogram(string):
        return len(string) == len(set(string))
</pre>
<h3>JavaScript</h3>
<pre>
    export const isIsogram = s => !s.match(/([a-z]).*\1/i);
    Here the \1 is called a backreference. To make sure that the pattern 
    looks for the closing quote exactly the same as the opening one, we 
    can wrap it into a capturing group and backreference it: (['"])(.*?)\1.

    const isogram = s => {
        return s.length === new Set(s).size
    }

    let str = `He said: "She's the one!".`;
    let regexp = /(['"])(.*?)\1/g;
    console.log( str.match(regexp) ); // "She's the one!"
</pre>
<h3>C#</h3>
<pre>
    using System;
    using System.Collections.Generic;

    public static class Isogram
    {
        public static bool IsIsogram(string word)
        {
            var charmap = new Dictionary<char, bool>();
            foreach (var key in word.ToLower())
            {
                if (Char.IsLetter(key)) 
                {
                    if (charmap.ContainsKey(key))
                    {
                        return false;
                    }
                    charmap.Add(key, true);
                }            
            }
            return true;
        }
    }
</pre>
<h3>Go</h3>
<pre>
    package isogram

    import "unicode"

    // IsIsogram checks for repetitions
    func IsIsogram(str string) bool {
        charmap := make(map[rune]bool)
        for _, v := range str {
            if unicode.IsLetter(v) {
                k := unicode.ToLower(v)
                if charmap[k] {
                    return false
                }
                charmap[k] = true
            }
        }
        return true
    }
</pre>

<hr />
<h2>Regex (findall) Set</h2>
<hr />
<h3>Python</h3>
<pre>
    import re

    def is_pangram(sentence):
        return len(set(re.findall(r'[a-z]', sentence.lower()))) == 26
</pre>
<h3>JavaScript</h3>
<pre>
    export const isPangram = str => new Set(str.toLowerCase().match(/[a-z]/g)).size===26;

    const isPangram = s => new Set(s.match(/[a-z]/ig)).size === 26;
</pre>
<h3>C#</h3>
<pre>
    using System;
    using System.Collections.Generic;

    public static class Pangram
    {
        public static bool IsPangram(string input)
        {
            var charmap = new Dictionary<char, bool>();
            foreach (var key in input.ToLower())
            {
                if (Char.IsLetter(key)) 
                {
                    if (!charmap.ContainsKey(key))
                    {
                        charmap.Add(key, true);
                    }               
                }             
            }
            return charmap.Count == 26;
        }
    }
</pre>
<h3>Go</h3>
<pre>
    package pangram

    import "unicode"

    // IsPangram tests if string is pangram
    func IsPangram(str string) bool {
        charmap := make(map[rune]bool)
        for _, v := range str {
            if unicode.IsLetter(v) {
                k := unicode.ToLower(v)
                charmap[k] = true
            }
        }
        return len(charmap) == 26
    }
</pre>

<hr />
<h2>Dictionary List Comprehension Map</h2>
<hr />
<h3>Python</h3>
<pre>
    def to_rna(dna_strand):
        strand_dict = {'G': 'C', 'C': 'G', 'T': 'A', 'A': 'U'}
        return ''.join(x for x in map(strand_dict.get, dna_strand))
</pre>
<h3>JavaScript</h3>
<pre>
    const strand_map = {'G': 'C', 'C': 'G', 'T': 'A', 'A': 'U'};
    export const toRna = dna_strand => dna_strand.split('').map(n => strand_map[n]).join('');
</pre>
<h3>C#</h3>
<pre>
    using System;
    using System.Collections.Generic;
    using System.Linq;

    public static class RnaTranscription
    {

        private static readonly Dictionary<char, char> Strand_Dict = new Dictionary<char, char>
        {
            {'A','U'},
            {'C','G'},
            {'G','C'},
            {'T','A'}
        };
        public static string ToRna(string nucleotide) => string.Concat(nucleotide.Select(s => Strand_Dict[s]));
    }
</pre>
<h3>Go</h3>
<pre>
    package strand

    // ToRNA returns dna rna map
    func ToRNA(dna string) (result string) {
        m := map[rune]rune{'G': 'C', 'C': 'G', 'T': 'A', 'A': 'U'}
        for _, r := range dna {
            result += string(m[r])
        }
        return
    }
</pre>

<hr />
<h2>ValueError Sum List Comprehension</h2>
<hr />
<h3>Python</h3>
<pre>
    def distance(strand_a, strand_b):
        if len(strand_a) != len(strand_b): 
            raise ValueError(f'Strands must have equal lengths')

        return sum(1 for i in range(len(strand_a)) if strand_a[i] != strand_b[i])
</pre>
<h3>JavaScript</h3>
<pre>
    export const compute = (strand_a, strand_b) => {
        if (strand_a.length != strand_b.length) {
          if (!strand_a) throw new Error('left strand must not be empty');
          if (!strand_b) throw new Error('right strand must not be empty');
          throw new Error('left and right strands must be of equal length');
        }
        
        let cnt = 0;
        for (let i = 0; i < strand_a.length; i++) {
          if (strand_a[i] != strand_b[i]) cnt++;
        }
      
        return cnt;
    }

    const hamming = (a, b) => {
        if (!a) throw new Error('Must have a');
        if (!b) throw new Error('Must have b');
        if (a.length != b.length) {
            throw new Error('Must be equal length');
        }
    
        let cnt = 0;
        a.split('').forEach((_, i) => {
            if (a.split('')[i] != b.split('')[i]) cnt++;
        });
        return cnt;
    }

    const hamming = (a, b) => {
        let cnt = 0;
        a.split('')
        .forEach((c, i) => {
            if (c != b.split('')[i]) cnt++;
        })
        return cnt;
    }
</pre>
<h3>C#</h3>
<pre>
    using System;
    using System.Linq;

    public static class Hamming
    {
        public static int Distance(string firstStrand, string secondStrand)
        {
            if (firstStrand.Length != secondStrand.Length)
            {
                throw new ArgumentException("Strand lengths must be equal.");
            }

            return firstStrand.Where((x, i) => x != secondStrand[i]).Count();
        }
    }
</pre>
<h3>Go</h3>
<pre>
    package hamming

    import "errors"

    //Distance by Exercism
    func Distance(a, b string) (int, error) {
        if len(a) != len(b) {
            return 0, errors.New("Strings must be of equal length")
        }

        cnt := 0
        for i := range a {
            if a[i] != b[i] {
                cnt++
            }
        }

        return cnt, nil
    }
</pre>

<hr />
<h2>DateTime TimeDelta</h2>
<hr />
<h3>Python</h3>
<pre>
    from datetime import timedelta

    def add(moment):
        return moment + timedelta(seconds=10**9)

    def giga(t):
        return t + timedelta(seconds=1e9)
    
    x = giga(datetime(2011, 4, 25, 0, 0))
    print(x) # 2043-01-01 01:46:40
</pre>
<h3>JavaScript</h3>
<pre>
    export const gigasecond = d => {
        return new Date(d.getTime() + (1000000000 * 1000));
    };

    const giga = t => new Date(t.getTime() + (1000000000 * 1000))
    const giga = t => new Date(t.getTime() + (1e9 * 1e3))
</pre>
<h3>C#</h3>
<pre>
    using System;

    public static class Gigasecond
    {
        public static DateTime Add(DateTime moment) => moment.AddSeconds(1000000000);
    }
</pre>
<h3>Go</h3>
<pre>
    // Package gigasecond should have a package comment that summarizes what it's about.
    package gigasecond

    // import path for the time package from the standard library
    import "time"

    // AddGigasecond should have a comment documenting it.
    func AddGigasecond(t time.Time) time.Time {
        return t.Add(time.Second * time.Duration(1000000000))
    }
</pre>

<hr />
<h2>Sum List Comprehension Str(Number) Map Reduce Chaining</h2>
<hr />
<h3>Python</h3>
<pre>
    def is_armstrong_number(number):
        return sum(int(i)**len(str(number)) for i in str(number)) == number
</pre>
<h3>JavaScript</h3>
<pre>
    export const isArmstrongNumber = number => {
        return number.toString()
                     .split('') 
                     .map(a => Math.pow(Number(a), number.toString().length))
                     .reduce((a, b) => a + b) === number;
    };

    const armstrong = n => {
        return n.toString()
        .split('')
        .map(i => Number(i)**n.toString().length)
        .reduce((a, b) => a + b) === n;
    }
</pre>
<h3>C#</h3>
<pre>
    using System;
    using System.Linq;

    public static class ArmstrongNumbers
    {
        public static bool IsArmstrongNumber(int number)
        {
            return number.ToString()
                        .Select(n => int.Parse(n.ToString()))
                        .Sum(n => Math.Pow(n, number.ToString().Count())) == number;
        }  
    }
</pre>
<h3>Go</h3>
<pre>
    // Explain 
    package armstrong

    import (
        "math"
        "strconv"
    )

    // IsNumber an Armstrong number?
    func IsNumber(number int) bool {
        sum := 0

        nums := strconv.Itoa(number)
        for i := range nums {
            n, _ := strconv.Atoi(string(nums[i]))
            sum += int(math.Pow(float64(n), float64(len(nums))))
        }

        return sum == number
    }
</pre>

<hr />
<h2>Sum of Squares Square of Sum Constructor Array Keys</h2>
<hr />
<h3>Python</h3>
<pre>
    def square_of_sum(number):
        return sum(n for n in range(1, number+1))**2

    def sum_of_squares(number):
        return sum(n**2 for n in range(1, number+1))

    def difference_of_squares(number):
        return square_of_sum(number) - sum_of_squares(number)
</pre>
<h3>JavaScript</h3>
<pre>
    export class Squares {
        constructor(n) {
          this.arr = Array.from(Array(n+1).keys());
        }
      
        get sumOfSquares() {
          return this.arr.reduce((a, b) => a + b**2);
        }
      
        get squareOfSum() {
          return this.arr.reduce((a, b) => (a + b))**2;
        }
      
        get difference() {
          return this.squareOfSum - this.sumOfSquares;
        }
    }
</pre>
<h3>C#</h3>
<pre>
    using System;
    using System.Linq;

    public static class DifferenceOfSquares
    {
        public static int CalculateSquareOfSum(int max) => (int)Math.Pow(Enumerable.Range(1, max).Sum(), 2);

        public static int CalculateSumOfSquares(int max) => Enumerable.Range(1, max).Select(x => x * x).Sum();

        public static int CalculateDifferenceOfSquares(int max) => CalculateSquareOfSum(max) - CalculateSumOfSquares(max);
    }
</pre>
<h3>Go</h3>
<pre>
    // Explain
    package diffsquares

    import "math"

    // SquareOfSum returns square of sum 1 to n
    func SquareOfSum(n int) int {
        var s int
        for i := 1; i <= n; i++ {
            s += i
        }
        return int(math.Pow(float64(s), 2))
    }

    // SumOfSquares returns sum of squares 1 to n
    func SumOfSquares(n int) int {
        var s float64
        for i := 1; i <= n; i++ {
            s += math.Pow(float64(i), 2)
        }
        return int(s)
    }

    // Difference returns SquareOfSum - SumOfSquares
    func Difference(n int) int {
        return SquareOfSum(n) - SumOfSquares(n)
    }
</pre>

<hr />
<h2>List Comprehension Range Sum If Array.from Filter Reduce</h2>
<hr />
<h3>Python</h3>
<pre>
    def sum_of_multiples(limit, multiples):
        return sum({i * m for m in multiples for i in range(limit) if i * m < limit})

    def sum_multiples(arr, lim):
        return sum({i for i in range(lim) for a in arr if i % a == 0})
</pre>
<h3>JavaScript</h3>
<pre>
    export const sum = (multiples, limit) => {
        return Array.from({length: limit - 1}, (_, i) => i + 1)
                .filter(i => multiples.some(m => i % m == 0))
                .reduce((acc, cv) => acc + cv, 0);
    };

    const sumMultiples = (arr, lim) => {
        return Array.from(Array(lim).keys())
                .filter(i => arr.some(n => i % n == 0))
                .reduce((a, b) => a + b)
    }
</pre>
<h3>C#</h3>
<pre>
    using System;
    using System.Collections.Generic;
    using System.Linq;

    public static class SumOfMultiples
    {
        public static int Sum(IEnumerable<int> multiples, int max)
        {
            int rtn_sum = 0;
            for (int i = 1; i < max; i++) 
            {
                if (multiples.Any(m => m != 0 && i % m == 0)) {
                    rtn_sum += i;
                }
            }
            return rtn_sum;
        }
    }
</pre>
<h3>Go</h3>
<pre>
    package summultiples

    // SumMultiples returns sum of multiples up to but not including limit
    func SumMultiples(limit int, multiples ...int) int {
        sum := 0
        for i := 1; i < limit; i++ {
            for _, m := range multiples {
                if m > 0 && i%m == 0 {
                    sum += i
                    break
                }
            }
        }
        return sum
    }
</pre>

<hr />
<h2>Class</h2>
<hr />
<h3>Python</h3>
<pre>
    class School:
        def __init__(self):
            self.school_roster = {}

        def add_student(self, name, grade):
            self.school_roster[name] = grade

        def get_roster(self):
            return sorted(self.school_roster.items(), key=lambda student: (student[1],student[0]), reverse=False)

        def roster(self):
            return [s[0] for s in self.get_roster()]

        def grade(self, grade_number):
            return [s[0] for s in self.get_roster() if s[1] == grade_number]

    class School:
        def __init__(self):
            self.students = {}
            
        @property
        def roster(self):
            return [s[0] for s in sorted(self.students.items(), key=lambda student: (student[1], student[0]))]
            
        def add(self, name, grade):
            self.students[name] = grade
            
        def grade(self, grade):
            return sorted(s for s, g in self.students.items() if g == grade)
</pre>
<h3>JavaScript</h3>
<pre>
    export class GradeSchool {
        constructor() {
            <!-- this.school = {};     -->
            this.students = {};
        }
      
        roster() {
            <!-- return JSON.parse(JSON.stringify(this.school)); -->
            let grades = new Set(Object.values(this.students).sort((a, b) => a - b));
            const sorted_roster = []
            grades.forEach( g => {
                sorted_roster.push(Object.entries(this.students)
                                .filter(s => s[1] === g)
                                .sort()
                                .reduce((arr, val) => arr.concat(val), []));
            });
            return JSON.parse(JSON.stringify(sorted_roster));
        };
      
        add(name, grade) {
            <!-- if ( this.school[grade] ) {
                this.school[grade] = this.school[grade].concat(name).sort();
            } else {
                this.school[grade] = [name];
            }  
            output { '2': [ 'Aimee' ] } -->
            
            this.students[name] = grade;  
        }
      
        grade(grade) {
            <!-- if ( this.school[grade] ) {
                return JSON.parse(JSON.stringify(this.school[grade]));
            } else {
                return [];
            } -->
            
            return JSON.parse(JSON.stringify(Object.entries(this.students).filter(s => s[1] === grade)));
        }
    }

    class School {
        constructor() {
            this.students = {}
        }
        
        get roster() {
            let grades = new Set(Object.values(this.students).sort())
            const sorted_roster = [];
            grades.forEach(g => {
                sorted_roster.push(Object.entries(this.students)
                                  .filter(s => s[1] == g)
                                  .sort()
                                  .reduce((arr, val) => arr.concat(val), []));
            });
            return JSON.parse(JSON.stringify(sorted_roster));
        }
        
        add(name, grade) {
            this.students[name] = grade;
        }
        
        grade(grade) {
            return JSON.parse(JSON.stringify(Object.entries(this.students).filter(g => g[1] === grade).sort()))
        }
    }
</pre>

<hr />
<h2>Class Random Choices @Property Get Shuffle ASCII</h2>
<hr />
<h3>Python</h3>
<pre>
    from random import choices
    from string import ascii_uppercase

    class Robot:
        def __init__(self):
            self.letters = [c for c in ascii_uppercase]
            self.numbers = [str(i) for i in range(10)]
            self.cache = set()
            self.create_name()

        @property
        def name(self):
            return self._name

        def reset(self):
            self.create_name()

        def create_name(self):    
            while True:
                self._name = ''.join(choices(self.letters, k=2)) + \
                            ''.join(choices(self.numbers, k=3))
                if self._name not in self.cache:
                    self.cache.add(self._name)
                    break
</pre>
<h3>JavaScript</h3>
<pre>
    class Robot {
        constructor() {
            this.cache = [];
            this.createName();
        }
    
        get name() {
            return this.cache[this.cache.length - 1]
        } 
    
        getLetter() {
            return String.fromCharCode(Math.floor(Math.random() * 26) + 65);
        }
    
        getNumber() {
            return Math.floor(Math.random() * 10);
        }
    
        createName() {
            while (this.cache.length < (26 * 26 * 10 * 10 * 10)) {
                let name =  [
                    this.getLetter(),
                    this.getLetter(),
                    this.getNumber(),
                    this.getNumber(),
                    this.getNumber()
                ].join('');
                
                if (!this.cache.includes(name)) {
                    this.cache.push(name);
                    break;
                } 
            }
        }
    }

    const shuffle = (lst) => {
        for (let i = lst.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [lst[i], lst[j]] = [lst[j], lst[i]];
        }
    }
    
    const getLetters = i => {
        return (i >= 26 ? getLetters((i / 26 >> 0) - 1) : '') +  'abcdefghijklmnopqrstuvwxyz'[i % 26 >> 0];
    }
    
    const getNumbers = (num, size) => {
        let s = num+"";
        while (s.length < size) s = "0" + s;
        return s;
    }
    
    const createBookOfRobotNames = () => {
        const letters = [];
        const names = [];
        for (let i = 26; i <= 701; i++) {
            letters.push(getLetters(i).toUpperCase());
        }
        for (let j of letters) {
            for (let k = 0; k < 1000; k++) {
                names.push(j + getNumbers(k, 3));
            }        
        };
        shuffle(names);
        return names;
    }
    
    let bookOfNames = []
    
    export class Robot {
        constructor() {
            this._name = this.getName();
        }
    
        get name() {
            return this._name;
        }
    
        reset() {
            this._name = this.getName();
        }
    
        getName() {        
            if (bookOfNames.length === 0) {
                bookOfNames = createBookOfRobotNames();
            }
            return bookOfNames.pop();
        }
    }
    
    Robot.releaseNames = () => {
        bookOfNames = []
    }
</pre>
<h3>C#</h3>
<pre>
    using System;
    using System.Linq;
    using System.Collections.Generic;

    public class Robot
    {
        private string name;
        private static readonly Random random = new Random();
        private static HashSet<string> cache = new HashSet<string>();
        
        public string Name
        {
            get
            {
                if (string.IsNullOrEmpty(name)) name = CreateName();
                return name;
            }
        }

        public string CreateName()
        {
            do
            {
                var letters = Enumerable.Range(0, 2)
                            .Aggregate("", (r, i) => r + 
                            (char)('A' + random.Next(0, 26)));
                var numbers = Enumerable.Range(0, 3)
                            .Aggregate("", (r, i) => r + 
                            random.Next(0, 9).ToString());
                name = letters + numbers;
            }
            while (!cache.Add(name));
            return name;
        }

        public string Reset()
        {
            return CreateName();
        }
    }
</pre>
<h3>Go</h3>
<pre>
    // Explain
    package robotname

    import (
        "fmt"
        "math/rand"
        "strconv"
    )

    // Robot Danger! Danger!
    type Robot string

    var cache = make(map[Robot]string)
    var namesavailable = 26 * 26 * 10 * 10 * 10

    // Name returns name
    func (r *Robot) Name() (n string, err error) {
        if cache[*r] != "" {
            return cache[*r], err
        }

        if len(cache) >= namesavailable {
            return "", fmt.Errorf("Names have been exhausted")
        }

        for {
            n = string(rune(rand.Intn(26)+65)) + string(rune(rand.Intn(26)+65)) + fmt.Sprintf("%03s", strconv.Itoa(rand.Intn(1000)))
            if _, ok := cache[Robot(n)]; !ok {
                *r = Robot(n)
                cache[*r] = n
                return n, err
            }
        }
    }

    // Reset resets name
    func (r *Robot) Reset() {
        *r = ""
        r.Name()
    }
</pre>

<hr />
<h2>Class F String Dictionary Objects Arrow Functions</h2>
<hr />
<h3>Python</h3>
<pre>
    class SpaceAge:
        def __init__(self, seconds):
            self.seconds = seconds
            self.year_seconds = 31557600
            self.ratios = {
                'earth': 1,
                'mercury': 0.2408467,
                'venus': 0.61519726,            
                'mars': 1.8808158,
                'jupiter': 11.862615,
                'saturn': 29.447498,
                'uranus': 84.016846,
                'neptune': 164.79132
            }
        
        def on_earth(self):
            return float(f'{self.seconds/self.year_seconds/self.ratios["earth"]:.2f}')

        def on_mercury(self):
            return float(f'{self.seconds/self.year_seconds/self.ratios["mercury"]:.2f}')

        def on_venus(self):
            return float(f'{self.seconds/self.year_seconds/self.ratios["venus"]:.2f}')

        def on_mars(self):
            return float(f'{self.seconds/self.year_seconds/self.ratios["mars"]:.2f}')

        def on_jupiter(self):
            return float(f'{self.seconds/self.year_seconds/self.ratios["jupiter"]:.2f}')

        def on_saturn(self):
            return float(f'{self.seconds/self.year_seconds/self.ratios["saturn"]:.2f}')

        def on_uranus(self):
            return float(f'{self.seconds/self.year_seconds/self.ratios["uranus"]:.2f}')

        def on_neptune(self):
            return float(f'{self.seconds/self.year_seconds/self.ratios["neptune"]:.2f}')
</pre>
<h3>JavaScript</h3>
<pre>
    export const SECS = 31557600;

    export const RATIOS = {
    mercury: 0.2408467,
        venus: 0.61519726,
        earth: 1,
        mars: 1.8808158,
        jupiter: 11.862615,
        saturn: 29.447498,
        uranus: 84.016846,
        neptune: 164.79132
    };

    export const age = (planet, seconds) => {
        return parseFloat((seconds / SECS / RATIOS[planet]).toFixed(2));
    };
</pre>
<h3>C#</h3>
<pre>
    using System;

    public class SpaceAge
    {
        private const double earth = 1;
        private const double mercury = 0.2408467;
        private const double venus = 0.61519726;
        private const double mars =  1.8808158;
        private const double jupiter = 11.862615;
        private const double saturn = 29.447498;
        private const double uranus = 84.016846;
        private const double neptune = 164.79132;
        private const double secs = 31557600;
        private readonly double seconds;
        public SpaceAge(double seconds) => this.seconds = seconds;
        public double OnEarth() => Math.Round(seconds / secs / earth, 2);
        public double OnMercury() => Math.Round(seconds / secs / mercury, 2);
        public double OnVenus() => Math.Round(seconds / secs / venus, 2);
        public double OnMars() => Math.Round(seconds / secs / mars, 2);
        public double OnJupiter() => Math.Round(seconds / secs / jupiter, 2);
        public double OnSaturn() => Math.Round(seconds / secs / saturn, 2);
        public double OnUranus() => Math.Round(seconds / secs / uranus, 2);
        public double OnNeptune() => Math.Round(seconds / secs / neptune, 2);
    }
</pre>
<h3>Go</h3>
<pre>
    // Explain
    package space

    import "math"

    // Planet should have a comment documenting it.
    type Planet string

    // Age should have a comment documenting it.
    func Age(seconds float64, planet Planet) float64 {
        var secs float64 = 31557600
        ratios := make(map[Planet]float64)

        ratios["Mercury"] = 0.2408467
        ratios["Venus"] = 0.61519726
        ratios["Earth"] = 1.0
        ratios["Mars"] = 1.8808158
        ratios["Jupiter"] = 11.862615
        ratios["Saturn"] = 29.447498
        ratios["Uranus"] = 84.016846
        ratios["Neptune"] = 164.79132

        return math.Round((seconds/secs/ratios[planet])*100) / 100
    }
</pre>

<hr />
<h2>Bitwise Operators ValueError</h2>
<hr />
<h3>Python</h3>
<pre>
    def square(number):
        if 0 < number < 65:
            # 2**(number-1)
            return 1 << (number-1)
            
        raise ValueError("ValueError exception thrown")

    def total():
        # (2**64) - 1
        return (1 << 64) - 1
</pre>
<h3>JavaScript</h3>
<pre>
    export const square = n => {
        if (n > 0 && n < 65) {
          return 1n << BigInt(n - 1);
        }
        throw new Error("square must be between 1 and 64");
    };
      
    export const total = () => 2n ** 64n - 1n;
</pre>
<h3>C#</h3>
<pre>
    using System;

    public static class Grains
    {
        public static ulong Square(int n)
        {
            if (n > 0 && n < 65)
            {
                return (ulong) 1 << (n - 1);
            }

            throw new ArgumentOutOfRangeException("Argument out of range exception");
        }

        public static ulong Total() => ulong.MaxValue;
    }
</pre>
<h3>Go</h3>
<pre>
    // Explain
    package grains

    import (
        "errors"
        "math"
    )

    // Square returns 1 << (n - 1)
    func Square(n int) (uint64, error) {
        if n > 0 && n < 65 {
            return 1 << uint(n-1), nil
        }
        return 0, errors.New("Invalid value error")
    }

    // Total returns MaxUint64
    func Total() uint64 {
        return math.MaxUint64
    }
</pre>

<hr />
<h2>Dictionary Comprehension Object Keys Nested Map</h2>
<hr />
<h3>Python</h3>
<pre>
    def transform(legacy_data):
        shiny_data = {i.lower(): k for k, v in legacy_data.items() for i in v}
        return {k:v for k, v in sorted(shiny_data.items())}
</pre>
<h3>JavaScript</h3>
<pre>
    export const transform = old => {
        const netl = {};
        Object.keys(old).map(k => old[k].map(v => netl[v.toLowerCase()] = +k));
        return netl;
    }
</pre>
<h3>C#</h3>
<pre>
    using System;
    using System.Collections.Generic;
    using System.Linq;

    public static class Etl
    {
        public static Dictionary<string, int> Transform(Dictionary<int, string[]> old) =>
            old.SelectMany(k => k.Value.Select(v => 
            new KeyValuePair<string, int>(v.ToLower(), k.Key)))
            .ToDictionary(d => d.Key, d => d.Value);
    }
</pre>
<h3>Go</h3>
<pre>
    // Explain
    package etl

    import "strings"

    // Transform remaps old format to new
    func Transform(old map[int][]string) map[string]int {
        n := make(map[string]int)
        for k, v := range old {
            for _, c := range v {
                n[strings.ToLower(c)] = k
            }
        }
        return n
    }
</pre>

<hr />
<h2>Prime Factors While /=</h2>
<hr />
<h3>Python</h3>
<pre>
    def factors(value):
        i = 2
        prime_factors = []
        while i <= value:
            while value % i == 0:
                prime_factors.append(i)
                value /= i
            i += 1

        return prime_factors
</pre>
<h3>JavaScript</h3>
<pre>
    export const primeFactors = value => {
        let i = 2;
        const prime_factors = [];
        while (i <= value) {
            while (value % i == 0) {
                prime_factors.push(i)
                value /= i
            }
            i++;
        }
        return prime_factors;
    };
</pre>
<h3>C#</h3>
<pre>
    using System;
    using System.Collections.Generic;

    public static class PrimeFactors
    {
        public static long[] Factors(long number)
        {
            List<long> prime_factors = new List<long>();
            long i = 2;
            while (i <= number)
            {
                while (number % i == 0)
                {
                    prime_factors.Add(i);
                    number /= i;
                }
                i++;
            }
            return prime_factors.ToArray();
        }
    }
</pre>
<h3>Go</h3>
<pre>
    // Explain
    package prime

    // Factors returns array of prime factors
    func Factors(v int64) []int64 {
        pfs := []int64{}
        var i int64 = 2
        for i <= v {
            for v%i == 0 {
                pfs = append(pfs, i)
                v /= i
            }
            i++
        }
        return pfs
    }
</pre>

<hr />
<h2>Matrix Constructor Get</h2>
<hr />
<h3>Python</h3>
<pre>
    class Matrix:
        def __init__(self, matrix_string):
            self.matrix = [[int(i) for i in row.split()] for row in matrix_string.split('\n')]

        def row(self, index):
            return self.matrix[index-1]

        def column(self, index):
            return [row[index-1] for row in self.matrix]
</pre>
<h3>JavaScript</h3>
<pre>
    export class Matrix {
        constructor(matrix) {
            this.row = matrix.split('\n').map(row => row.split(' ').map(Number));
            this.col = this.row[0].map((_,i) => this.row.map(v => v[i]));
        }
      
        get rows() {
            return this.row; 
        }
      
        get columns() {
            return this.col;
        }
    }
</pre>
<h3>C#</h3>
<pre>
    using System;
    using System.Linq;

    public class Matrix
    {
        private int[][] matrix;

        public Matrix(string input)
        {
            matrix = input.Split('\n')
                .Select(arr => arr.Split(' ')
                .Select(i => int.Parse(i)).ToArray())
                .ToArray();
        }

        public int Rows 
        {
            get => matrix.Count();
        }

        public int Cols
        {
            get => matrix[0].Count();
        }

        public int[] Row(int row) => matrix[row - 1];
        public int[] Column(int col) => matrix.Select(i => i[col - 1]).ToArray();
    }
</pre>
<h3>Go</h3>
<pre>
    // Explain
    package matrix

    import (
        "errors"
        "strconv"
        "strings"
    )

    // Matrix type created
    type Matrix [][]int

    // New returns type Matrix
    func New(s string) (Matrix, error) {
        a := strings.Split(s, "\n")
        m := make(Matrix, len(a))
        for i, v := range a {
            w := strings.Split(strings.TrimSpace(v), " ")
            wa := make([]int, len(w))
            for j, k := range w {
                k1, err := strconv.Atoi(k)
                if err == nil {
                    wa[j] = k1
                } else {
                    return nil, errors.New("Invalid Number")
                }
            }
            m[i] = wa
            if len(m[0]) != len(m[i]) {
                return nil, errors.New("Invalid Array Size")
            }
        }
        return m, nil
    }

    // Rows returns rows of type Matrix
    func (m Matrix) Rows() [][]int {
        result := make([][]int, len(m))
        for i := 0; i < len(m); i++ {
            result[i] = make([]int, len(m[i]))
            for j := 0; j < len(m[i]); j++ {
                result[i][j] = m[i][j]
            }
        }
        return result
    }

    // Cols returns columns of type Matrix
    func (m Matrix) Cols() [][]int {
        result := make([][]int, len(m[0]))
        for i := 0; i < len(m[0]); i++ {
            result[i] = make([]int, len(m))
            for j := 0; j < len(m); j++ {
                result[i][j] = m[j][i]
            }
        }
        return result
    }

    // Set returns comparison bool
    func (m Matrix) Set(row, col, val int) bool {
        if row < 0 || col < 0 || row >= len(m) || col >= len((m)[0]) {
            return false
        }
        (m)[row][col] = val
        return true
    }
</pre>

<hr />
<h2>Itertools Cycle Chain</h2>
<hr />
<h3>Python</h3>
<pre>
    from itertools import cycle, chain

    def encode(message, rails):
        msg_map = zip(message, cycle(chain(range(rails), range(rails-2, 0, -1))))
        return ''.join([i[0] for i in sorted(msg_map, key=lambda x: x[1])])

    def decode(encoded_message, rails):
        enc_seq = cycle(chain(range(rails), range(rails-2, 0, -1)))
        enc_map = sorted(zip(range(len(encoded_message)), enc_seq), key=lambda x: x[1])
        dec_map = zip(enc_map, encoded_message)
        return ''.join(c[1] for c in sorted(dec_map))
</pre>

<hr />
<h2>Itertools Islice Count ValueError</h2>
<hr />
<h3>Python</h3>
<pre>
    import itertools

    def prime_gen():
        D = {}
        yield 2
        for q in itertools.islice(itertools.count(3), 0, None, 2):
            p = D.pop(q, None)
            if p is None:
                D[q * q] = 2 * q
                yield q
            else:
                x = p + q
                while x in D:
                    x += p
                D[x] = p

    def prime(number):
        if number == 0:
            raise ValueError("There is no zeroth prime")

        return [p for i, p in zip(range(number), prime_gen())][-1]
</pre>

<hr />
<h2>Saddle Points Enumerate Zip *Matrix Unpacking Lists ...Matrix</h2>
<hr />
<h3>Python</h3>
<pre>
    def saddle_points(matrix):    
        if [row for row in matrix if len(row) != len(matrix[0])]:
            raise ValueError("Rows need to be of equal length")

        sps = []
        for i, row in enumerate(matrix):
            for j, col in enumerate(zip(*matrix)):          
                if max(row) <= min(col):
                    sps.append({'row': i+1, 'column': j+1})
    
        return sps
</pre>
<h3>JavaScript</h3>
<pre>
    export const saddlePoints = matrix => {
        const sps = [];
        let transMatrix = matrix[0].map((_, cidx) => matrix.map(row => row[cidx]));
        for (let i = 0; i < matrix.length; i++) {
            for (let j = 0; j < transMatrix.length; j++) {
                if (Math.max(...matrix[i]) <= Math.min(...transMatrix[j])) {
                    sps.push({'row': i+1, 'column': j+1});
                }
            }
        }
        return sps;
    }
</pre>

<hr />
<h2>Functools Reduce ValueError Array From Map Flat Sort Slice Reduce</h2>
<hr />
<h3>Python</h3>
<pre>
    from functools import reduce

    def classify(number):
        if number <= 0:
            raise ValueError('Number needs to be a natural number')
        
        factors = list(set(reduce(list.__add__, ([i, number//i] for i in range(1, int(number**0.5) + 1) if number % i == 0))))

        if number == sum(sorted(factors)[:-1]):
            return 'perfect'    
        if number < sum(sorted(factors)[:-1]):
            return 'abundant'
        return 'deficient'
</pre>
<h3>JavaScript</h3>
<pre>
    export const classify = n => {
        if (n <= 0) throw new Error('Classification is only possible for natural numbers.');
        if (n < 6) return 'deficient';
        
        const getFactors = i => {
          const factors = []
          if (n % i === 0) {
            factors.push(i);
            if (n / i !== 1) {
              factors.push(n / i);
            }
          }
          return factors;
        }
      
        let sum = Array
                    .from(Array(Math.ceil(Math.sqrt(n))), (_, i) => i)
                    .map(getFactors)
                    .flat()
                    .sort((a, b) => a - b)
                    .slice(0, -1)
                    .reduce((a, b) =>(a + b));
      
        if (n === sum) return 'perfect';
        if (n < sum) return 'abundant';
        return 'deficient';
    };
</pre>

<hr />
<h2>2**i</h2>
<hr />
<h3>Python</h3>
<pre>
    def commands(number):
        actions = ['wink', 'double blink', 'close your eyes', 'jump']
        handshake = [actions[i] for i in range(len(actions)) if number & 2**i]
        return handshake[::-1] if number & 2**len(actions) else handshake
</pre>

<hr />
<h2>Itertools Product</h2>
<hr />
<h3>Python</h3>
<pre>
    from itertools import product

    def has_errors(min_factor, max_factor):
        if min_factor > max_factor:
            raise ValueError('min_factor cannot be greater than max_factor')

        if max_factor - min_factor <= 1:
            return 1
            
    def factors(k, fmin, fmax):
        f_array = [[l, k//l] for l in range(1, int(k**0.5) + 1) if k % l == 0]
        return [f for f in f_array if min(f) >= fmin and max(f) <= fmax]
    
    def get_palindrome(r, fmin, fmax):
        if has_errors(fmin, fmax): return [None, []] 

        products = product(r, repeat=2)
        for i in products:
            p = i[0] * i[1]
            if str(p) == str(p)[::-1]:
                return [p, factors(p, fmin, fmax)]

    def largest(min_factor, max_factor): 
        fmin = min_factor - 1 if max_factor < 10 else max_factor - min_factor
        r = range(max_factor, fmin, -1)
        return get_palindrome(r, min_factor, max_factor)

    def smallest(min_factor, max_factor):
        r = range(min_factor, min_factor * 2)
        return get_palindrome(r, min_factor, max_factor)
</pre>

<hr />
<h2>Class Chess Queen</h2>
<hr />
<h3>Python</h3>
<pre>
    class Queen:
        def __init__(self, row, column):
            if min([row, column]) >= 0 and max([row, column]) < 8:
                self.row = row
                self.col = column
            else:
                raise ValueError("ValueError exception thrown")

        def can_attack(self, another_queen):
            if [self.row, self.col] == [another_queen.row, another_queen.col]:
                raise ValueError("ValueError exception thrown")

            if self.row == another_queen.row or self.col == another_queen.col:
                return True

            if abs(self.row - another_queen.row) == abs(self.col - another_queen.col):
                return True

            return False
</pre>

<hr />
<h2>List Index</h2>
<hr />
<h3>Python</h3>
<pre>
    def color_code(color):
        return colors().index(color)

    def colors():
        return [
                "black",
                "brown",
                "red",
                "orange",
                "yellow",
                "green",
                "blue",
                "violet",
                "grey",
                "white"
            ]
</pre>
<h3>JavaScript</h3>
<pre>
    export const colorCode = (color) => {
        return COLORS.indexOf(color);
    };
      
    export const COLORS = ["black","brown","red","orange","yellow","green","blue","violet","grey","white"];
</pre>
<h3>C#</h3>
<pre>
    using System;

    public static class ResistorColor
    {
        public static int ColorCode(string color) => Array.IndexOf(Colors(), color);
        public static string[] Colors() => new[] { "black", "brown", "red", "orange", "yellow", "green", "blue", "violet", "grey", "white" };
    }
</pre>

</body>
</html>